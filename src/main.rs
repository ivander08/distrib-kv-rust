// src/main.rs (Conceptual changes for the loop)
mod core_types;

use crate::core_types::{RpcMessage, Server, NodeState, RequestVoteArgs, AppendEntriesArgs, RequestVoteReply, AppendEntriesReply};
use std::thread;
use std::time::Duration;

fn main() {
    println!("--- Simplified Raft KV Store Simulation ---");

    let all_server_ids: Vec<u64> = vec![1, 2, 3];
    let total_servers = all_server_ids.len();

    let mut servers: Vec<Server> = all_server_ids
        .iter()
        .map(|&id| {
            let peer_ids_for_this_server: Vec<u64> = all_server_ids
                .iter()
                .cloned()
                .filter(|&p_id| p_id != id)
                .collect();
            Server::new(id, peer_ids_for_this_server) // Pass peer_ids to new()
        })
        .collect();

    for tick_num in 0..500 { // Simulate more ticks to see elections potentially complete
        println!("\n--- TICK {} ---", tick_num);
        
        let mut messages_this_round: Vec<(u64, u64, RpcMessage)> = Vec::new(); // (sender_id, receiver_id, message)

        // 1. Servers generate messages from their tick logic
        for server_idx in 0..servers.len() {
            // Cannot borrow servers mutably twice. So we need to handle messages after all ticks.
            // Or, for tick that might return messages (like becoming leader and sending heartbeats):
            // let outgoing_messages = servers[server_idx].tick(); // tick now takes no peers arg
            // for (target_id, rpc_message) in outgoing_messages {
            //     messages_this_round.push((servers[server_idx].id, target_id, rpc_message));
            // }
        }
        
        // We need to be careful about mutable borrows.
        // Let's collect all messages generated by tick() first.
        let mut all_outgoing_rpcs_from_tick: Vec<(u64, u64, RpcMessage)> = Vec::new();
        for server in servers.iter_mut() {
            let outgoing_rpcs = server.tick(); // tick() now uses self.peer_ids
            for (target_peer_id, rpc_message) in outgoing_rpcs {
                all_outgoing_rpcs_from_tick.push((server.id, target_peer_id, rpc_message.clone())); // Clone message
            }
        }
        messages_this_round.extend(all_outgoing_rpcs_from_tick);


        // 2. "Deliver" messages and collect replies to deliver in the NEXT round
        // This simple loop doesn't fully handle replies going back to the original sender's handler method correctly yet.
        // A more robust simulation would queue replies.
        let mut replies_this_round: Vec<(u64, u64, RpcMessage)> = Vec::new(); // (original_sender, original_receiver (now sender of reply), reply_message)


        println!("--- Delivering {} messages this tick ---", messages_this_round.len());
        for (sender_id, receiver_id, rpc_message) in messages_this_round {
            if let Some(receiver_server) = servers.iter_mut().find(|s| s.id == receiver_id) {
                println!("[SimNetwork] Delivering from S{} to S{}: {:?}", sender_id, receiver_id, rpc_message);
                match rpc_message {
                    RpcMessage::RequestVote(args) => {
                        let reply = receiver_server.handle_request_vote(args);
                        println!("[S{}] VoteReply to S{}: {:?}", receiver_server.id, sender_id, reply);
                        replies_this_round.push((sender_id, receiver_server.id, RpcMessage::RequestVoteReply(reply)));
                    }
                    RpcMessage::AppendEntries(args) => {
                        let reply = receiver_server.handle_append_entries(args);
                        println!("[S{}] AppendEntriesReply to S{}: {:?}", receiver_server.id, sender_id, reply);
                        replies_this_round.push((sender_id, receiver_server.id, RpcMessage::AppendEntriesReply(reply)));
                    }
                    _ => { /* This sender part only sends requests for now */ }
                }
            }
        }
        
        // 3. Deliver replies (original_sender is now the receiver_of_reply)
        if !replies_this_round.is_empty() {
            println!("--- Delivering {} replies this tick ---", replies_this_round.len());
        }
        for (receiver_of_reply_id, sender_of_reply_id, rpc_reply_message) in replies_this_round {
             if let Some(original_sender_server) = servers.iter_mut().find(|s| s.id == receiver_of_reply_id) {
                println!("[SimNetworkReply] Delivering reply from S{} to S{}: {:?}", sender_of_reply_id, receiver_of_reply_id, rpc_reply_message);
                match rpc_reply_message {
                    RpcMessage::RequestVoteReply(reply_args) => {
                        // Candidate processes the vote reply
                        if let Some(msgs_if_leader) = original_sender_server.handle_request_vote_reply(reply_args, sender_of_reply_id, total_servers) {
                            // If became leader, it wants to send heartbeats
                            for (target_peer_id, rpc_message) in msgs_if_leader {
                                // Queue these for next round of message sending
                                // For simplicity, we might need another vector for "next_tick_messages"
                                // or just print them for now.
                                println!("[S{}] Became LEADER, wants to send to S{}: {:?}", original_sender_server.id, target_peer_id, rpc_message);
                            }
                        }
                    }
                    RpcMessage::AppendEntriesReply(reply_args) => {
                        // Leader processes the append entries reply
                        // original_sender_server.handle_append_entries_reply(reply_args, sender_of_reply_id); // Method TBD
                         println!("[S{}] Received AppendEntriesReply from S{} (handler TBD): {:?}", original_sender_server.id, sender_of_reply_id, reply_args);
                    }
                    _ => {}
                }
            }
        }


        // Print summary of server states
        println!("--- Server States after Tick {} ---", tick_num);
        for server_idx in 0..servers.len() {
            print_server_details_brief(&servers[server_idx]);
        }

        thread::sleep(Duration::from_millis(200)); // Slow down for readability
    }
}

fn print_server_details_brief(server: &Server) {
    println!(
        "S{}: Term={}, State={:?}, LogLen={}, Commit={}, Applied={}, VotedFor={:?}, VotesGot={}",
        server.id,
        server.current_term,
        server.state,
        server.log.len(),
        server.commit_index,
        server.last_applied,
        server.voted_for,
        server.votes_received.len() // Show votes received
    );
}
// Keep your more detailed print_server_details if you like